generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id          String        @id @default(uuid())
  username    String        @unique
  email       String        @unique
  password    String
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  groups      GroupMember[]
  predictions Prediction[]
  ownedGroups Group[]       @relation("GroupOwner")

  @@index([username])
  @@index([email])
}

model Group {
  id          String        @id @default(uuid())
  name        String
  isPublic    Boolean       @default(true)
  ownerId     String
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  owner       User          @relation("GroupOwner", fields: [ownerId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  members     GroupMember[]
  predictions Prediction[]

  @@index([isPublic])
  @@index([ownerId])
  @@index([name])
}

model GroupMember {
  id       Int     @id @default(autoincrement())
  userId   String
  groupId  String
  joinedAt DateTime @default(now())

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@unique([groupId, userId]) // prevents duplicate membership
  @@index([userId])
  @@index([groupId])
}

model Match {
  id          String    @id @default(uuid())
  competition String
  player1     String
  player2     String
  startTime   DateTime
  score       String?
  winner      String?   // consider enum or player refs later
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([startTime])
  @@index([competition, startTime])
}

model Prediction {
  id        String   @id @default(uuid())
  userId    String
  groupId   String
  matchId   Int
  winnerId  Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  // One prediction per user per match inside a specific group
  @@unique([userId, groupId, matchId])

  @@index([userId])
  @@index([groupId])
  @@index([matchId])
}
